%----------------------------------------------------------------------------
\chapter{Background}
%----------------------------------------------------------------------------
%TODO general chapter intro

%----------------------------------------------------------------------------
\section{Model-Based Engineering} \label{sec_backgrmbe}
%----------------------------------------------------------------------------
Due to the application of the modeling concept in several completely different domains, first of all, we need to define the meaning of \textit{model} in this work.
\begin{definition}[Model]
	A model is the simplified image of an element of the real or a hypothetical world (the system), that replaces the the system in certain considerations.
\end{definition}

For a model to be interpretable, executable or formally verifiable, it must be described according to predefined rules in the given domain. This set of rules is provided by \textit{modeling languages}.
\begin{definition}[Modeling Language]
	A modeling language consists of the following elements:
	\begin{itemize}
		\item \emph{Metamodel:} a model defining the building blocks of the modeling language as well
		as their relationships.
		\item \emph{Concrete syntax:} a set of rules defining a graphical or textual notation for the
		element and connection types defined in the metamodel.
		\item \emph{Well-formedness constraints:} a set of constraints that models have to meet in order
		to be deemed valid in the modeling language.
		\item \emph{Semantics:} a set of rules that define the meaning of the element and connection
		types defined in the metamodel. Semantics can be either \textit{operational} (what should happen during execution) or \textit{denotational} (given by translating concepts in a modeling language to another modeling language with well-defined semantics).
	\end{itemize}
\end{definition}

Models can grasp various aspects of a system. Structural models describe the structure of the system, representing knowledge regarding the parts of the system and the properties and connections of these parts. This means that the model describes static knowledge and not temporal change. On the other hand, behavioral models describe the change of the system over time through its changing of states and execution of processes. These categories do not cover every aspect of a system, and usually cannot be separated this well in practical applications. For instance, action languages of state-based models describe the behavior of the system in a procedural way. There are several possible formalisms for both kinds of models, some of which are discussed in Section \ref{sec_backgrmodeling}.

The process of deriving design artifacts is called \textit{model transformation}.
\begin{definition}[Model Transformation]
	Model transformation is the process of generating the target model from the source model. This process is described by by a transformation definition consisting of transformation rules, and a transformation tool that executes them. A transformation rule is the mapping of elements of the source model to the elements of the target model. \cite{ModelTransformation}
\end{definition}

Model transformations can be categorized based on the types of the source and target models: model-to-model (M2M), model-to-text (M2T), text-to-model (T2M) and text-to-text (T2T). These categories fundamentally define the tools required and usable for handling the different models.

There are also two important factors to consider when designing a model transformation: 
\begin{itemize}
	\item \textit{Consistency}: the same structure or behavior is described by the source and the target models (in their respective domains).
	\item \textit{Traceability}: the images of the original elements of the source model can be traced back to the original elements, from which they were generated.
\end{itemize}

\textbf{Model-based systems engineering (MBSE)} is the formalized application of modeling to support system requirements, design, analysis, verification and validation activities beginning in the conceptual design phase and continuing throughout development and later life cycle phases \cite{mbse}. This concept can also be applied to software engineering. Note, that the models may be the primary artifact of the development process, in which case formal models are required -- as described above.

%----------------------------------------------------------------------------
\section{Foundations of Automata Theory} \label{sec_backgrmodeling}
%----------------------------------------------------------------------------
%TODO DFA, NFA

%TODO LTS (Kripke?)

%TODO Mealy

%TODO Regular languages vs automata

%TODO Omega-regular languages if needed

%TODO Logics (esp LTL) -> ezt külön kiszedjük vagy ide be?

%----------------------------------------------------------------------------
\section{Automata Learning} \label{sec_backgrautomatalearning}
%----------------------------------------------------------------------------
%TODO active vs passive

%TODO Active

%TODO DHC

%----------------------------------------------------------------------------
\section{Specifying Requirements} \label{sec_backgrspecreq}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Requirements} \label{subs_backgrreq}
%----------------------------------------------------------------------------

Throughout this thesis, the concept of requirements is going to be used widely, therefore, it is essential to define it precisely. 

\begin{definition}[Requirement\cite{sweterminology}]
	\mbox{}
	\begin{enumerate}
		\setlength\itemsep{0.1em}
		\item A condition or capability needed by the user to solve a problem or achieve an objective.
		\item A condition or capability that must be met or possessed by a system component to satisfy a contract, standard, specification or other formally imposed documents.
		\item A documented representation of a condition or capability as in (1) or (2).
	\end{enumerate}
\end{definition}

Requirements are important, as the specification is present at both the beginning and the end of the software development project: the design can only start, if there are some requirements formulated, and acceptance tests are only possible in the presence of requirements.

Requirements can be specified in many different ways, the most common being textual requirements in traditional feature lists. This method is an informal way of requirements specification, as the structure of this format is hard to analyze due to it lacking a precise definition. Attempts were made to formalize this type of requirements by defining patterns and mapping the individual patterns to formal semantics, for instance in [TODO cite (form)], however, there are also less direct approaches, such as temporal logic. 

The rationale behind the formalization of requirements is the wide range of automatized applications called \textit{formal methods} -- such as validation, formal verification, test oracle generation and requirement documentation generation.

%----------------------------------------------------------------------------
\subsection{Linear-Time Temporal Logic} \label{subs_backgrltl}
%----------------------------------------------------------------------------

