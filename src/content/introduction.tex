%----------------------------------------------------------------------------
\chapter{\bevezetes}
%----------------------------------------------------------------------------

\textbf{Context} Model-based engineering is the formalized application of modeling during system design and development. It improves the efficiency of designing and developing IT systems by formalizing verification, code generation and system analysis, and in some cases enables their automation as well. Such models can be designed both manually and in automated ways, by applying various model synthesis techniques. In case of behavioral models, a straightforward way of description is state-based modeling, which - due to the advancements of formal analysis techniques in recent years - can be widely and effectively utilized when analyzing systems. A possible way of synthesizing automaton-based models is to apply active automata learning algorithms. 

\textbf{Problem Statement} Acquiring a correct model of a system can be challenging. On one hand, it is difficult for the designing engineer to keep every property of the envisioned system in mind at a given time, partly because of the complexity of the system, and because of possible hidden implications and contradictions. Additionally, to conveniently specify requirements, different scopes, abstractions and formalisms may be applied, which may be difficult to reconcile. On the other hand, there are fully automated solutions -- usually stricter in these aspects --, for instance, active automata learning, where the model construction is characterised by a teacher component - which is familiar with the extensive behavior of the system under learning - and a learner component - which synthesises the model via queries to the teacher component. However, such solutions have practical boundaries when validating the inferred behavior of the system.

\textbf{Objective} The objective of our work is to support the design of systems and components from the ground up through a semi-automated solution -- \textit{InterActive} automata learning --  which utilizes both the frequent input of the designing engineers and automated techniques. As a result of this approach, the users themselves are regarded as the teacher component of the algorithm, resolving the infeasibility of automated equivalence validation. This results in a semi-automated solution driven by declarative behavioral requirement specification, which allows the designing engineers to focus on the exptected behavior of the system and evaluating the model proposed by the algorithm.

\textbf{Contribution} The thesis presents an adaptive state-based modeling framework combining the advantages of manual and automated solutions, into which we designed and integrated the interactive algorithm. We created a proof of concept implementation of the approach, allowing system design through different formalisms, and the analysis and development of interactive automata learning algorithms to support model-driven development with an extended scope.
\clearpage

\textbf{Related Work} There are multiple automaton learning frameworks in the literature, including
\emph{LearnLib}\cite{10.1007/978-3-319-21690-4_32} that provides a Java framework for active and passive automaton learning, \emph{libalf}, which provides learning techniques for finite automata implemented in \emph{C++} and \emph{Tomte}\cite{aarts2012automata}, a framework utilizing LearnLib for counterexample driven abstraction refinement of real software components modeled in a restricted class of finite automata.

In \cite{angluin2020strongly} Dana Angluin et al. predict strongly unambiguous BÃ¼chi-automata using automata learning. Cobleigh et al. use active automata learning through multiple oracles to learn assumptions for compositional verification\cite{cobleigh2003learning}. Groce et al. utilize model checking as an equivalence oracle of active automaton learning to automatically handle inconsistent models through Adaptive Model Checking\cite{groce2002adaptive}. Giannakopoulou et al. utilize active automata learning and symbolic execution to learn temporal component interfaces\cite{giannakopoulou2012symbolic}.


\textbf{Outline} The paper is organized as follows. Chapter \ref{background} provides an outline of the necessary theoretical background. Chapter \ref{overviewoftheapproach} gives an overview of our approach, both in methodology and architecture. Chapter \ref{implementation} describes the tools and steps taken to create a proof of concept implementation to validate our approach. Chapter \ref{casestudy} presents a case study to demonstrate the capabilities and limitations of the implementation and the approach. Chapter \ref{evaluation} evaluates the components of the implementation. Chapter \ref{conclusion} concludes the thesis and presents the possible future work.




